{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Burrito Documentation","text":"<p>This is the home of the Burrito documentation. Here you will find all the information you need to get started with Burrito.</p> <ul> <li>Overview helps you understand what Burrito is all about.</li> <li>Getting Started is a step-by-step guide to help you get started with Burrito.</li> <li>Guides provides detailed tutorials to help you understand how to use Burrito.</li> <li>Operator Manual is a detailed guide to help you understand how to install and configure Burrito.</li> <li>User Guide is a detailed guide to help you understand how to setup and use Burrito resources.</li> <li>Contributing provides information on how to contribute to the Burrito project.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>First off, thank you for considering contributing to Burrito! Your support helps make this project better for everyone.</p> <p>The following is a set of tutorials and guidelines for contributing to Burrito. These are mostly guidelines, not rules. Use your best judgment, and feel free to propose changes to this document.</p>"},{"location":"contributing/#how-can-i-contribute","title":"How Can I Contribute?","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, please report it by opening an issue on the issue tracker. Before reporting, please check whether the issue has already been reported.</p> <ul> <li>Ensure the bug hasn't been reported yet.</li> <li>Use a clear and descriptive title.</li> <li>Provide detailed steps to reproduce the issue.</li> <li>Include any relevant logs or screenshots.</li> </ul>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>We welcome suggestions for improvements. Please use the issue tracker to submit enhancement requests.</p> <ul> <li>Use a clear and descriptive title.</li> <li>Explain why this enhancement would be useful.</li> <li>Provide examples or mockups if possible.</li> </ul>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":"<ul> <li>Set up a development environment following the steps below.</li> <li>Read the Development Guidelines.</li> <li>Submit contributions!</li> </ul>"},{"location":"contributing/#getting-started-set-up-a-local-development-environment-kind","title":"Getting Started: Set Up a Local Development Environment (kind)","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>A container runtime (docker, podman, etc.)</li> <li>Git</li> <li>Kind</li> <li>Helm</li> <li><code>kubectl</code></li> <li><code>yq</code></li> <li><code>make</code></li> </ul> <p>To run an instance of Burrito, you will need a Kubernetes cluster. This tutorial uses Kind as a local development Kubernetes cluster.</p> <p>Follow Kind's quick start tutorial to set up a local cluster.</p> <p>Once your cluster is up and running, follow the next steps to compile and deploy Burrito.</p>"},{"location":"contributing/#basic-install","title":"Basic Install","text":"<p>Follow these steps to install a minimal working configuration of Burrito on a Kind cluster:</p> <ul> <li>Cert-manager</li> <li>Burrito controllers in the <code>burrito-system</code> namespace</li> <li>A datastore running with mock storage (in-memory)</li> <li>A <code>TerraformRepository</code> and an associated <code>TerraformLayer</code> resource in the <code>burrito-project</code> namespace, pointing to the padok-team/burrito-examples repository</li> </ul> <p>Before starting, check that your local Kind cluster is running and that your context is set to target this cluster.</p> <ol> <li> <p>Install cert-manager on your cluster:</p> <pre><code>helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm upgrade --install -n cert-manager --create-namespace cert-manager bitnami/cert-manager --set installCRDs=true\n</code></pre> </li> <li> <p>Fork and clone this repository.</p> </li> <li> <p>Run the following command to build a local image of Burrito, load it into your Kind cluster, and install Burrito with development Helm values:</p> <pre><code>make upgrade-dev-kind\n</code></pre> </li> <li> <p>Check that Burrito is running in the <code>burrito-system</code> namespace:</p> <pre><code>kubectl get pods -n burrito-system\n</code></pre> <p>The output should be similar to:</p> <pre><code>NAME                                  READY   STATUS    RESTARTS   AGE\nburrito-controllers-7657b7455-2ldtd   1/1     Running   0          5m32s\nburrito-datastore-5967f46497-tfzgg    1/1     Running   0          5m32s\nburrito-server-5b6fb78949-ngcnt       1/1     Running   0          5m32s\n</code></pre> </li> <li> <p>Create layers and repository resources:</p> <p>Create a <code>dev</code> directory in <code>deploy/charts/burrito/templates/</code> and add a <code>dev.yaml</code> manifest with development resources:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n    name: my-layer\n    namespace: burrito-project\nspec:\n    branch: main\n    path: terraform/\n    repository:\n        name: my-repository\n        namespace: burrito-project\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n    name: my-repository\n    namespace: burrito-project\nspec:\n    repository:\n        url: https://github.com/padok-team/burrito-examples\n    remediationStrategy:\n        autoApply: true\n    terraform:\n        enabled: true\n    opentofu:\n        enabled: false\n    terragrunt:\n        enabled: false\n</code></pre> </li> <li> <p>Refresh your Helm configuration:</p> <pre><code>make upgrade-dev-helm\n</code></pre> </li> <li> <p>Check that a runner pod is created for the newly created layer:</p> <pre><code>kubectl get pods -n burrito-project\n</code></pre> <p>The output should be similar to:</p> <pre><code>NAME                   READY   STATUS      RESTARTS   AGE\nmy-layer-apply-gxjhd   0/1     Completed   0          2m36s\n</code></pre> </li> </ol>"},{"location":"contributing/#refresh-commands","title":"Refresh Commands","text":"<p>To build a new local image of Burrito, push it into your local Kind cluster, and update the Helm release with the new image tag, run the following:</p> <pre><code>make upgrade-dev-kind\n</code></pre> <p>To refresh the Helm chart with development values, run:</p> <pre><code>make upgrade-dev-helm\n</code></pre> <p>Check the Makefile for more details about these commands.</p>"},{"location":"contributing/#advanced-settings","title":"Advanced Settings","text":"<p>Configure a GitHub Token for TENV:</p> <p>It is strongly recommended to create a GitHub token with no specific rights to bypass the GitHub API rate limiting. Append the following configuration to your development <code>TerraformRepository</code> resources:</p> <pre><code>  overrideRunnerSpec:\n    env:\n      - name: TENV_GITHUB_TOKEN\n        value: ghp_xxxxx\n</code></pre>"},{"location":"contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for new features or bug fixes.</li> <li>Run all tests to ensure existing functionality isn't broken (<code>make test</code>).</li> <li>Ensure code coverage remains at the same level or higher.</li> </ul>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<ul> <li>Please follow the convention described by Conventional Commits.</li> <li>If you don't, the CI pipeline will fail.</li> </ul>"},{"location":"contributing/#additional-resources","title":"Additional Resources","text":"<ul> <li>Controller-runtime documentation (Burrito heavily relies on this package)</li> <li>Burrito documentation</li> </ul>"},{"location":"contributing/#debugging-burrito","title":"Debugging Burrito","text":"<p>To debug Burrito efficiently in Kubernetes, you can use Delve, optionally with Visual Studio Code (recommended). We have set a few things to help you getting started.</p> <p>You'll need to follow instructions in Getting Started: Set Up a Local Development Environment (kind) to get a local Kubernetes development instance.</p>"},{"location":"contributing/#enable-debugging","title":"Enable debugging","text":"<p>First, being by installing dlv: <code>go install github.com/go-delve/delve/cmd/dlv@latest</code></p> <p>We'll rely on <code>deploy/charts/burrito/values-debug.yaml</code> to deploy the configuration to start the debugging session.</p> <p>By default, the different component debug configs are commented in the Helm values. Indeed, starting the application with dlv server will hang until you connect with the dlv client so it has to be enabled only when you need it.</p> <pre><code># config:\n#   burrito:\n#     runner:\n#       command: [\"/usr/local/bin/dlv\"]\n#       args: [\"--listen=0.0.0.0:2346\", \"--headless=true\", \"--accept-multiclient\", \"--api-version=2\", \"--log\", \"exec\", \"/usr/local/bin/burrito\", \"runner\", \"start\"]\n\n# controllers:\n#   deployment:\n#     mode: Debug\n#     command: [\"/usr/local/bin/dlv\"]\n#     args: [\"--listen=0.0.0.0:2345\", \"--headless=true\", \"--accept-multiclient\", \"--api-version=2\", \"--log\", \"exec\", \"/usr/local/bin/burrito\", \"controllers\", \"start\"]\n\n# datastore:\n#   deployment:\n#     mode: Debug\n#     command: [\"/usr/local/bin/dlv\"]\n#     args: [\"--listen=0.0.0.0:2347\", \"--headless=true\", \"--accept-multiclient\", \"--api-version=2\", \"--log\", \"exec\", \"/usr/local/bin/burrito\", \"datastore\", \"start\"]\n\n# server:\n#   deployment:\n#     mode: Debug\n#     command: [\"/usr/local/bin/dlv\"]\n#     args: [\"--listen=0.0.0.0:2348\", \"--headless=true\", \"--accept-multiclient\", \"--api-version=2\", \"--log\", \"exec\", \"/usr/local/bin/burrito\", \"server\", \"start\"]\n</code></pre> <p>Note</p> <p>The runner command+args override isn't under <code>runner.deployment</code> as other components as it's not a k8s deployment</p> <p>Tip</p> <p>You can also launch burrito with the debug build and override command+args in <code>overrideRunnerSpec</code> in a specific layer you'd like to debug.</p> <p>By default, we'll start the application with the usual command. If you want to debug the controller or the runner, uncomment the required block. This will open a port on the pod on which you'll connect from your computer.</p> <p><code>mode: Debug</code> is removing liveness and readiness probes: they won't be able to start as dlv will await for you to start the debugging session.</p>"},{"location":"contributing/#deployrefresh-commands","title":"Deploy/refresh commands","text":"<p>You'll need to deploy the debug container images and config. This is the same command if you need to refresh your deployment.</p> <p>To build a new local debug image of Burrito, push it into your local Kind cluster, and update the Helm release with the new image tag, run the following:</p> <pre><code>make upgrade-debug-kind\n</code></pre> <p>To refresh the Helm chart with debug values, run:</p> <pre><code>make upgrade-debug-helm\n</code></pre> <p>Check the Makefile for more details about these commands.</p>"},{"location":"contributing/#connect-from-your-computer-to-the-debug-session","title":"Connect from your computer to the debug session","text":"<p>The debugging port won't be exposed by default so you'll need to port-forward it.</p> <ul> <li>For the controller:</li> </ul> <pre><code>kubectl port-forward $(kubectl get pods -n burrito-system | awk '/burrito-controllers.*Running/{print $1}') -n burrito-system 2345:2345\n</code></pre> <ul> <li>For the runner:</li> </ul> <pre><code>kubectl port-forward -n burrito-project &lt;layerName&gt; 2346:2346\n</code></pre> <p>It will listen on the same port than the controller so we're exposing it on port 2346 on your computer so you can debug the controller and the runner if needed.</p> <ul> <li>For the datastore:</li> </ul> <pre><code>kubectl port-forward $(kubectl get pods -n burrito-system | awk '/burrito-datastore.*Running/{print $1}') -n burrito-system 2347:2347\n</code></pre> <ul> <li>For the server:</li> </ul> <pre><code>kubectl port-forward $(kubectl get pods -n burrito-system | awk '/burrito-server.*Running/{print $1}') -n burrito-system 2348:2348\n</code></pre>"},{"location":"contributing/#start-debugging","title":"Start debugging","text":""},{"location":"contributing/#with-vscode","title":"With vscode","text":"<p>Note</p> <p>You can get more information about Vscode+Go debugging here</p> <p>If you want to use Vscode to debug the app, you'll need to get the Go extension and create a <code>.vscode/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Attach to Controller\",\n            \"type\": \"go\",\n            \"request\": \"attach\",\n            \"mode\": \"remote\",\n            \"port\": 2345,\n            \"host\": \"127.0.0.1\",\n            \"apiVersion\": 2\n        },\n        {\n            \"name\": \"Attach to Runner\",\n            \"type\": \"go\",\n            \"request\": \"attach\",\n            \"mode\": \"remote\",\n            \"port\": 2346,\n            \"host\": \"127.0.0.1\",\n            \"apiVersion\": 2\n        },\n        {\n            \"name\": \"Attach to Datastore\",\n            \"type\": \"go\",\n            \"request\": \"attach\",\n            \"mode\": \"remote\",\n            \"port\": 2347,\n            \"host\": \"127.0.0.1\",\n            \"apiVersion\": 2\n        },\n        {\n            \"name\": \"Attach to Server\",\n            \"type\": \"go\",\n            \"request\": \"attach\",\n            \"mode\": \"remote\",\n            \"port\": 2348,\n            \"host\": \"127.0.0.1\",\n            \"apiVersion\": 2\n        }\n    ]\n}\n</code></pre> <p>New to debugging on Vscode?</p> <p>For a vscode debug introduction, you can check Debug code with Visual Studio Code.</p> <p>Browse your code to set breakpoints by clicking on the left side of your line.</p> <p></p> <p>Open the <code>Run and Debug</code> pane, select your debugging configuration and hit <code>F5</code> to connect to the remove <code>dlv</code>.</p> <p></p> <p>Once your line is reached, vscode will show you the variables, current stack, etc</p> <p></p>"},{"location":"contributing/#with-dlv","title":"With <code>dlv</code>","text":"<p>If you prefer to debug on cli, you can connect with <code>dlv connect 127.0.0.1:&lt;debuggingPort&gt;</code> where <code>&lt;debuggingPort&gt;</code> is 2345, 2346, 2347 or 2348, depending on what you're debugging.</p>"},{"location":"faq/","title":"TODO - FAQ","text":""},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster</li> <li>[Optional for testing, necessary for production use] A storage bucket in a cloud provider (AWS, GCP, Azure)</li> <li>[Optional, recommended for production use] cert-manager installed in your cluster (for internal encryption of plans and logs &amp; provider cache)</li> </ul>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>helm CLI</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>) to access your Kubernetes cluster</li> </ul>"},{"location":"getting-started/#1-install-burrito","title":"1. Install Burrito","text":"<p>Copy and modify the default values to match your requirements.</p> <p>Make sure to configure a tenant by updating the <code>tenant</code> field in the <code>values.yaml</code> file. The associated namespace will be created automatically and used to deploy Burrito resources in step 3.</p> <p>For example, here is a default <code>values.yaml</code> file:</p> <pre><code>config:\n  burrito:\n    datastore:\n      storage:\n        mock: true\n\ntenants:\n  - namespace:\n      create: true\n      name: \"burrito-project-1\"\n    serviceAccounts:\n      - name: \"runner-project-1\"\n</code></pre> <p>Info</p> <p>To try Burrito without setting up a remote storage, set the <code>config.burrito.datastore.storage.mock</code> field to <code>true</code> in the <code>values.yaml</code> file. To persist data such as Terraform logs, you must configure a storage bucket field. Make sure to specify a service account that has the necessary permissions to read/write to your remote bucket.</p> <p>Then, install Burrito using the following command:</p> <pre><code>helm install burrito oci://ghcr.io/padok-team/charts/burrito --create-namespace -n burrito-system -f ./values.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito-system</code>, where Burrito services will be deployed.</p>"},{"location":"getting-started/#2-create-a-connection-to-a-private-repository","title":"2. Create a connection to a private repository","text":"<p>Create a Kubernetes <code>Secret</code> to reference the necessary credentials to clone your IaC repository (GitHub or GitLab)</p> <p>Info</p> <p>Supported authentication methods are:</p> <ul> <li>Username and password</li> <li>SSH private key</li> <li>GitHub App</li> <li>GitHub API token</li> <li>GitLab API token</li> </ul> <p>More information on how to create a secret can be found in the Git Authentication section.</p> <pre><code>kind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: &lt;tenant-namespace&gt;\ntype: Opaque\nstringData:\n  username: &lt;my-username&gt;\n  password: &lt;my-password | my-access-token&gt;\n  sshPrivateKey: |\n    -----BEGIN OPENSSH PRIVATE KEY-----\n    ...\n    -----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Then, create a <code>TerraformRepository</code> Kubernetes resource. The <code>spec.terraform.enabled</code> sets the repository as a Terraform repository (as opposed to an OpenTofu repository). This setting will propagate to all layers linked to this repository by default, but can be overridden at the layer level.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: &lt;tenant-namespace&gt;\nspec:\n  repository:\n    url: &lt;https-or-ssh-repository-url&gt;\n    secretName: burrito-repo\n  terraform:\n    enabled: true\n</code></pre> <p>Info</p> <p>You can also connect to a public repository by omitting <code>spec.repository.secretName</code> in your <code>TerraformRepository</code> definition.</p>"},{"location":"getting-started/#3-synchronize-a-terraform-layer","title":"3. Synchronize a Terraform layer","text":"<p>After creating a <code>TerraformRepository</code> you can create a <code>TerraformLayer</code> resource which looks like:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/terraform/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>The controller will create a runner pod in your tenant namespace to synchronize the repository and apply the Terraform code.</p>"},{"location":"getting-started/#guides","title":"Guides","text":"<ul> <li>For detailed guides on how to use Burrito, see the Guides section.</li> <li>To learn more about advanced configuration and features, see the Operator Manual section.</li> </ul>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#what-is-burrito","title":"What is Burrito?","text":"<p>Burrito is a TACoS (Terraform Automation Collaboration Software) Kubernetes Operator.</p> <p>Burrito is designed to help you manage and automate your infrastructure as code in a Kubernetes-native way. In simple terms, it aims at being the ArgoCD for Infrastructure as Code.</p> <p></p>"},{"location":"overview/#why-burrito","title":"Why Burrito?","text":"<p><code>terraform</code> is a tremendous tool to manage your infrastructure in IaC. However, it lacks built-in solutions for</p> <ul> <li>Managing state drift.</li> <li>Continuous planning and applying of your Terraform code.</li> <li>Easy navigation of Terraform state.</li> </ul>"},{"location":"overview/#state-drift","title":"State Drift","text":"<p>Burrito provides a way to continuously plan your Terraform code and apply it. This way, you can ensure that your infrastructure is always up to date with your code, or at least be aware of the drift. This is especially useful when you have multiple people working on the same Terraform codebase. Burrito will help you detect drifts and resolve them before they become a problem.</p>"},{"location":"overview/#continuous-planning-and-applying","title":"Continuous Planning and Applying","text":"<p>Configuring a CI/CD pipeline for Terraform can be challenging because it often varies depending on the selected tools. Burrito offers an out-of-the-box PR/MR integration, so you don't have to write CI/CD pipelines for Terraform ever again. This ensures that you won't have to deal with:</p> <ul> <li>Managing state locks.</li> <li>Managing Terraform versions.</li> <li>Saving Terraform plan logs and results.</li> <li>Integrating auditing tools (like Checkov).</li> </ul> <p>When a PR/MR is opened, Burrito will automatically plan the Terraform code and comment on the MR/PR with the plan. This way, you can easily see the impact of the changes before applying them. Once the PR/MR is merged, Burrito will apply the Terraform code.</p>"},{"location":"overview/#navigation-of-your-terraform-state","title":"Navigation of Your Terraform State","text":"<p>With its curated UI, Burrito provides a way to easily navigate your Terraform state, see the resources, and their dependencies. This way, you can easily see the impact of a change before applying it. [Not yet implemented]</p>"},{"location":"overview/#compatibility","title":"Compatibility","text":"<p>Burrito is compatible with:</p> <ul> <li>Terraform</li> <li>Terragrunt</li> <li>OpenTofu</li> </ul>"},{"location":"overview/#getting-started","title":"Getting Started","text":"<ul> <li>Follow the getting started section to quickly set up Burrito and start monitoring Terraform state drift.</li> <li>Follow the guides for detailed tutorials on how to use Burrito.</li> <li>Deep dive into the operator manual to set up advanced configurations and features.</li> <li>Use the user guide to learn how to configure Burrito resources according to your needs.</li> </ul>"},{"location":"guides/","title":"Getting started","text":"<p>Follow the 3 guides below to understand how to use Burrito:</p> <ul> <li>IaC Drift detection: Quickly set up Burrito and start monitoring Terraform state drift.</li> <li>PR/MR plan/apply Workflow: Configure Burrito to automatically plan and apply Terraform code on PR/MR.</li> <li>UI Overview: Learn how to navigate the Burrito UI.</li> </ul>"},{"location":"guides/iac-drift-detection/","title":"Burrito Drift Detection","text":"<p>Drift detection is the core feature of Burrito. It allows you to monitor the drift between your Terraform state and your infrastructure in real-time. Burrito continuously plans your Terraform code by launching runner pods that will download the Terraform code, plan it, and store the result in its datastore.</p>"},{"location":"guides/iac-drift-detection/#exercise","title":"Exercise","text":"<p>Follow the steps below to set up Burrito on a local cluster and start planning your Terraform code automatically.</p>"},{"location":"guides/iac-drift-detection/#requirements","title":"Requirements","text":"<ul> <li>A Kubernetes cluster (you can use kind for a local cluster)</li> <li>Helm CLI</li> <li>kubectl CLI</li> </ul>"},{"location":"guides/iac-drift-detection/#install-burrito","title":"Install Burrito","text":"<p>Install Burrito with Helm as described in the installation guide, using the provided values file.</p> <pre><code>helm upgrade --install burrito oci://ghcr.io/padok-team/charts/burrito -n burrito-system -f https://raw.githubusercontent.com/padok-team/burrito/main/docs/examples/values-simple.yaml\n</code></pre> <p>With this command, you installed burrito with the following configuration:</p> <pre><code>config:\n  burrito:\n    controller:\n      timers:\n        driftDetection: 10m # run drift detection every 10 minutes\n        onError: 10s # wait 10 seconds before retrying on error\n        waitAction: 1m # wait 1 minute before retrying on locked layer\n        failureGracePeriod: 30s # set a grace period of 30 seconds before retrying on failure (increases exponentially with the amount of failed retries)\n    datastore:\n      storage:\n        mock: true # use a mock storage for the datastore (useful for testing, not recommended for production)\ntenants:\n  - namespace:\n      create: true\n      name: \"burrito-project\"\n</code></pre> <p>Burrito should be up and running in the <code>burrito-system</code> namespace.</p> <pre><code>kubectl get pods -n burrito-system\n</code></pre> <p>Output:</p> <pre><code>NAME                                   READY   STATUS    RESTARTS   AGE\nburrito-controllers-6945797c5d-kjfl2   1/1     Running   0          2m00s\nburrito-datastore-94d999f54-kbg9z      1/1     Running   0          2m00s\nburrito-server-764f75766b-qw5nx        1/1     Running   0          2m00s\n</code></pre>"},{"location":"guides/iac-drift-detection/#connect-burrito-to-terraform-code-on-github","title":"Connect Burrito to Terraform code on GitHub","text":"<p>You will use the example Terraform code that we have prepared for you. This repository contains simple Terraform and Terragrunt with local random-pets resources that you can use to test Burrito.</p> <p>Create a TerraformRepository resource in the <code>burrito-system</code> namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/padok-team/burrito/main/docs/examples/terraform-repository.yaml\n</code></pre> <p>Here is the content of the <code>TerraformRepository</code> resource that you have created. It references the GitHub repository containing the Terraform code. It also specifies that the IaC is Terraform code (as opposed to OpenTofu code). This setting will propagate to all layers linked to this repository by default, but can be overridden at the layer level.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito-examples\n  terraform:\n    enabled: true\n</code></pre> <p>Create a <code>TerraformLayer</code> resource in the <code>burrito-system</code> namespace, referencing the <code>TerraformRepository</code> you just created. For now, the <code>autoApply</code> is set to false, so the layer will only plan the Terraform code and not apply it.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/padok-team/burrito/main/docs/examples/terraform-layer.yaml\n</code></pre> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: my-layer\n  namespace: burrito-project\nspec:\n  branch: main\n  path: terraform\n  remediationStrategy:\n    autoApply: false\n  repository:\n    name: my-repository\n    namespace: burrito-project\n</code></pre> <p>Check that your Terraform code is being planned by Burrito:</p> <pre><code>kubectl get pods -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME                   READY   STATUS      RESTARTS   AGE\nmy-layer-apply-xntrg   0/1     Completed   0          82s\n</code></pre> <p>The <code>TerraformLayer</code> should have been updated with the result of the plan. You can check the status of the <code>TerraformLayer</code> directly by querying the <code>TerraformLayer</code> resource, or by checking the burrito UI.</p> <pre><code>kubectl get tfl -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME       STATE         REPOSITORY      BRANCH   PATH        LAST RESULT\nmy-layer   ApplyNeeded   my-repository   main     terraform   Plan: 3 to create, 0 to update, 0 to delete\n</code></pre> <pre><code>kubectl port-forward svc/burrito-server -n burrito-system 8080:80\n</code></pre> <p></p> <p>Activate the <code>autoApply</code> feature by updating the <code>TerraformLayer</code> resource:</p> <pre><code>kubectl patch tfl my-layer -n burrito-project --type merge --patch '{\"spec\":{\"remediationStrategy\":{\"autoApply\":true}}}'\n</code></pre> <p>Check that the Terraform code was applied:</p> <pre><code>kubectl get pods -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME                   READY   STATUS      RESTARTS   AGE\nmy-layer-apply-bxlcr   0/1     Completed   0          54s\nmy-layer-plan-jv86k    0/1     Completed   0          7m22s\n</code></pre> <pre><code>kubectl get tfl -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME       STATE   REPOSITORY      BRANCH   PATH        LAST RESULT\nmy-layer   Idle    my-repository   main     terraform   Apply Successful\n</code></pre>"},{"location":"guides/iac-drift-detection/#conclusion","title":"Conclusion","text":"<p>You have successfully set up Burrito on a local cluster and planned your Terraform code automatically. You can now monitor the drift between your Terraform state and your infrastructure in real-time.</p>"},{"location":"guides/iac-drift-detection/#next-steps","title":"Next steps","text":"<ul> <li>Learn how to configure a PR/MR workflow</li> </ul>"},{"location":"guides/pr-mr-workflow/","title":"PR/MR workflow","text":"<p>Now that you have set up Burrito and planned your Terraform code automatically, you can configure a PR/MR workflow to never have to use the <code>terraform apply</code> command ever again.</p>"},{"location":"guides/pr-mr-workflow/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You have set up Burrito on a cluster.</li> <li>You set up TerraformRepository and TerraformLayer resources to plan your Terraform code automatically.</li> </ul>"},{"location":"guides/pr-mr-workflow/#setup-a-webhook-and-github-app-for-your-repository","title":"Setup a webhook and GitHub app for your repository","text":"<p>To trigger the Burrito plan and apply workflow, you need to set up a webhook from your repository to your Burrito instance. Fork the burrito-examples repository and update the <code>TerraformRepository</code> resource to point to your forked repository.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/&lt;your-github-handle&gt;/burrito-examples\n  terraform:\n    enabled: true\n</code></pre> <p>You will also need to setup a GitHub App to allow Burrito to comment on your PRs/MRs. Follow the instructions in the PR/MR workflow section of the operator manual to set up the GitHub app. Make sure that you created a secret associated to your repository that include the GitHub app ID, installation ID, and private key.</p> <p>Note</p> <p>You can also use a personal access token instead of a GitHub app. Your GitHub account will be used to comment on the PRs/MRs. The secret should include the personal access token in the <code>githubToken</code> key.</p> <p>Now let's configure the GitHub webhook. Expose the <code>burrito-server</code> kubernetes service to the internet using the method of your choice. (for testing purposes on a local cluster, you can use <code>kubectl port-forward</code> and ngrok to expose the service to the internet).</p> <p>Configure a webhook in your GitHub repository to point to the exposed <code>burrito-server</code> service. Make sure to specify the <code>/api/webhook</code> path in the target url. The webhook should be triggered on <code>push</code> and <code>pull_request</code> events. Reference your webhook secret in the secret associated to your repository, in the <code>webhookSecret</code> key.</p> <p>Your <code>TerraformRepository</code> resource and secret should look like this:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/&lt;your-github-handle&gt;/burrito-examples\n    secretName: burrito-secret\n  terraform:\n    enabled: true\n---\nkind: Secret\nmetadata:\n  name: burrito-webhook-secret\n  namespace: burrito-project\ntype: Opaque\nstringData:\n  githubAppId: \"123456\"\n  githubAppInstallationId: \"12345678\"\n  githubAppPrivateKey: |\n    -----BEGIN RSA PRIVATE KEY-----\n    my-private-key\n    -----END RSA PRIVATE KEY-----\n  webhookSecret: \"my-webhook-secret\"\n</code></pre>"},{"location":"guides/pr-mr-workflow/#experiment-with-the-prmr-workflow","title":"Experiment with the PR/MR workflow","text":"<p>Now that you have set up the webhook and GitHub app, you can experiment with the PR/MR workflow. Create a new branch in your forked repository and make some changes to the Terraform code. Push the changes to the branch and open a PR/MR against the main branch.</p> <p>A new TerraformPullRequest resource should be created in your tenant namespace. You can check the status of the resource by running:</p> <pre><code>kubectl get pr -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME              ID    STATE   PROVIDER   BASE   BRANCH\nmy-repository-1   1     Idle    github     main   update-tf-code\n</code></pre> <p>A new TerraformLayer resource should also be created to plan the Terraform code. You can check the status of the resource by running:</p> <pre><code>kubectl get tfl -n burrito-project\n</code></pre> <p>Output:</p> <pre><code>NAME                  STATE         REPOSITORY      BRANCH           PATH        LAST RESULT\nmy-layer              ApplyNeeded   my-repository   main             terraform   Plan: 3 to create, 0 to update, 0 to delete\nmy-layer-pr-1-rxvrt   ApplyNeeded   my-repository   update-tf-code   terraform   Plan: 2 to create, 0 to update, 0 to delete\n</code></pre> <p>The Burrito server should have commented on the PR/MR with the plan output. You can check the comments on the PR/MR to see the plan output.</p> <p></p> <p>Set the <code>autoApply</code> field to <code>true</code> in the TerraformLayer resource to automatically apply the Terraform code upon merging the PR/MR.</p>"},{"location":"guides/pr-mr-workflow/#conclusion","title":"Conclusion","text":"<p>You have now set up a PR/MR workflow with Burrito to automatically plan and apply your Terraform code. You can now focus on writing Terraform code and let Burrito handle the rest.</p>"},{"location":"guides/pr-mr-workflow/#next-steps","title":"Next steps","text":"<ul> <li>Navigate the Burrito UI to see the status of the Terraform resources.</li> </ul>"},{"location":"guides/ui/","title":"UI Overview","text":"<p>The Burrito UI is a web-based interface that allows you to view the state of your Terraform layers and resources, as well as the drift between the desired and actual state of your infrastructure.</p>"},{"location":"guides/ui/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>A running Burrito installation</li> </ul>"},{"location":"guides/ui/#accessing-the-ui","title":"Accessing the UI","text":"<p>The Burrito UI is accessible via a web browser. To access the UI, you need to expose the <code>burrito-server</code> service locally or on a public URL.</p>"},{"location":"guides/ui/#features","title":"Features","text":""},{"location":"guides/ui/#homepage","title":"Homepage","text":"<p>The homepage displays a list of all the Terraform layers that have been added to Burrito. Each layer is displayed as a card with the following information:</p> <ul> <li>Namespace</li> <li>Repository</li> <li>Branch</li> <li>Code path</li> <li>Last plan result</li> <li>State (Error, Out-of-sync, OK)</li> </ul> <p></p>"},{"location":"guides/ui/#terraform-terragrunt-logs","title":"Terraform / Terragrunt logs","text":"<p>Click on the layer card to view the Terraform or Terragrunt logs for that layer. You can explore previous runs and view the logs for each run. The maximum number of logs to keep is configurable. </p> <p>A dedicated page for exploring the logs is also available.</p>"},{"location":"guides/ui/#more-to-come","title":"More to come","text":"<p>Burrito is under active development, and we are working on adding more features to the UI such as:</p> <ul> <li>\"Plan and apply\" buttons</li> <li>Notifications</li> <li>User management</li> <li>Pull request view   ... and more!</li> </ul>"},{"location":"installation/with-helm/","title":"Install burrito with Helm","text":""},{"location":"installation/with-helm/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool</li> <li>Installed helm command-line tool (version v3.8.0 and further)</li> <li>Have access to a Kubernetes cluster</li> </ul>"},{"location":"installation/with-helm/#1-basic-installation","title":"1. Basic installation","text":"<p>Info</p> <p>Our Helm chart is published in an OCI-based registry (ghcr.io). You must use Helm v3.8.0 or above.</p> <pre><code>helm install burrito oci://ghcr.io/padok-team/charts/burrito -n burrito-system --create-namespace\n</code></pre> <p>This will create a new namespace, <code>burrito-system</code>, where the burrito core components will live.</p> <p>You can change the chart's version with any version available on our Chart registry.</p>"},{"location":"installation/with-helm/#2-burrito-helm-configuration","title":"2. Burrito Helm configuration","text":"<p>The Burrito configuration is managed through Helm values files, which can be overridden at installation time.</p> <p>You can find the default values of the Burrito Helm chart by running:</p> <pre><code>helm show values oci://ghcr.io/padok-team/charts/burrito\n</code></pre> <p>The source code and values file of the chart is available on burrito GitHub repository.</p> <p>Here is an example of a simple burrito Helm values file that you can use to bootstrap your installation:</p> <pre><code>config:\n  burrito:\n    controller:\n      timers:\n        driftDetection: 10m # run drift detection every 10 minutes\n        onError: 10s # wait 10 seconds before retrying on error\n        waitAction: 1m # wait 1 minute before retrying on locked layer\n        failureGracePeriod: 30s # set a grace period of 30 seconds before retrying on failure (increases exponentially with the amount of failed retries)\n    datastore:\n      storage:\n        mock: true # use a mock storage for the datastore (useful for testing, not recommended for production)\ntenants:\n  - namespace:\n      create: true\n      name: \"burrito-project\"\n    serviceAccounts:\n    - name: burrito-runner\n      annotations:\n        iam.gke.io/gcp-service-account: burrito@company-project.iam.gserviceaccount.com # example: use GKE Workload Identity to have access to GCP infrastructure\n</code></pre> <p>Info</p> <p>Learn more about these values in the chart's README file and Multi-tenant architecture.</p>"},{"location":"installation/with-static-manifests/","title":"Install burrito with static manifests","text":""},{"location":"installation/with-static-manifests/#requirements","title":"Requirements","text":"<ul> <li>Installed kubectl command-line tool.</li> <li>Have a kubeconfig file (default location is <code>~/.kube/config</code>).</li> </ul>"},{"location":"installation/with-static-manifests/#install-burrito","title":"Install burrito","text":"<p>Info</p> <p>This will install a mono-tenant version of burrito. See the Helm installation method for a multi-tenant-architecture.</p> <pre><code>kubectl create namespace burrito\nkubectl apply -n burrito -f https://raw.githubusercontent.com/padok-team/burrito/main/manifests/install.yaml\n</code></pre> <p>This will create a new namespace, <code>burrito</code>, where burrito services will live.</p> <p>Warning</p> <p>The installation manifests include <code>ClusterRoleBinding</code> resources that reference <code>burrito</code> namespace. If you are installing burrito into a different namespace then make sure to update the namespace reference.</p>"},{"location":"operator-manual/","title":"Overview","text":"<p>This guide is for administrator and operator wanting to install and configure burrito for other developers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"operator-manual/advanced-configuration/","title":"Advanced configuration","text":"<p>Here are some important configuration options that can be set to customize Burrito's behavior. They can be set in the Helm chart values or as environment variables.</p>"},{"location":"operator-manual/advanced-configuration/#controllers-configuration","title":"Controllers' configuration","text":"Environment variable Description Default <code>BURRITO_CONTROLLER_NAMESPACES</code> list of namespaces to watch (comma-separated) <code>burrito-system</code> <code>BURRITO_CONTROLLER_TYPES</code> list of controllers to start <code>layer,repository,run,pullrequest</code> <code>BURRITO_CONTROLLER_TIMERS_DRIFTDETECTION</code> period between two plans for drift detection <code>20m</code> <code>BURRITO_CONTROLLER_TIMERS_ONERROR</code> period between two runners launch when an error occurred in the controllers <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_WAITACTION</code> period between two runners launch when a layer is locked <code>1m</code> <code>BURRITO_CONTROLLER_TIMERS_FAILUREGRACEPERIOD</code> initial time before retry, goes exponential function of number failure <code>15s</code> <code>BURRITO_CONTROLLER_TERRAFORMMAXRETRIES</code> default number of retries for terraform runs (can be overriden in CRDs) <code>5</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ENABLED</code> whether leader election is enabled or not <code>true</code> <code>BURRITO_CONTROLLER_LEADERELECTION_ID</code> lease id used for leader election <code>6d185457.terraform.padok.cloud</code> <code>BURRITO_CONTROLLER_HEALTHPROBEBINDADDRESS</code> address to bind the health probe server embedded in the controllers <code>:8081</code> <code>BURRITO_CONTROLLER_METRICSBINDADDRESS</code> address to bind the metrics server embedded in the controllers <code>:8080</code> <code>BURRITO_CONTROLLER_KUBERNETESWEBHOOKPORT</code> port used by the validating webhook server embedded in the controllers <code>9443</code> <code>BURRITO_CONTROLLER_MAXCONCURRENTRECONCILES</code> number of parallel resource reconciliation performed by the contoller <code>0</code> <code>BURRITO_CONTROLLER_MAXCONCURRENTRUNNERPODS</code> maximum number for pods that run in parallel to perform plan/apply (0=inf) <code>0</code>"},{"location":"operator-manual/advanced-configuration/#servers-configuration","title":"Server's configuration","text":"Environment variable Description Default <code>BURRITO_SERVER_ADDR</code> address the server listens on <code>:8080</code> <p>Info</p> <p>For webhook configuration see Setup a git webhook.</p>"},{"location":"operator-manual/advanced-configuration/#runners-configuration","title":"Runners' configuration","text":"<p>Currently, runners' configuration is not exposed.</p> <p>Info</p> <p>You can override some of the runner's pod spec. See override the runner pod spec documentation.</p>"},{"location":"operator-manual/architecture/","title":"Architectural Overview","text":""},{"location":"operator-manual/architecture/#components","title":"Components","text":""},{"location":"operator-manual/architecture/#the-server","title":"The server","text":"<p>The server is a REST server which exposes the API consumed by the Web UI. It has the following responsibilities:</p> <ul> <li>listener for Git webhook events</li> </ul> <p>Other features will be implemented when the Web UI will be in development.</p>"},{"location":"operator-manual/architecture/#the-repository-controller","title":"The repository Controller","text":"<p>The repository controller is a Kubernetes Controller which is only used to register <code>TerraformRepository</code> resources.</p>"},{"location":"operator-manual/architecture/#the-layer-controller","title":"The layer Controller","text":"<p>The layer controller is a Kubernetes Controller which continuously monitors declared <code>TerraformLayer</code> resources. It regurlarly creates <code>TerraformRun</code> resources which run a <code>terraform plan</code> for each of your layer to check if a drift has been introduced. If so, it has the possibility to create a <code>TerraformRun</code> that does a <code>terraform apply</code>.</p> <p>It is also responsible for running your Terraform <code>plan</code> and <code>apply</code> if there is a new commit on your layer.</p>"},{"location":"operator-manual/architecture/#the-run-controller","title":"The run Controller","text":"<p>The run controller is a Kubernetes Controller which continuously monitors declared <code>TerraformRun</code> resources.</p> <p>It is responsible for running the <code>terraform plan</code> and <code>terraform apply</code> commands by creating runner pods. It handles failure and retries of the runner pods.</p> <p>It also generates <code>Leases</code> to make sure no concurrent terraform commands will be launched on the same layer at the same time.</p>"},{"location":"operator-manual/architecture/#the-datastore-instance","title":"The Datastore instance","text":"<p>The Datastore instance of Burrito is a http proxy that provides download/upload capabilities to the runners. It is used to store the Terraform plan files generated by the runners and to store the associated logs.</p>"},{"location":"operator-manual/architecture/#implementation","title":"Implementation","text":"<p>The operator has been bootstrapped using the <code>operator-sdk</code>.</p> <p>The CLI used to start the different components is implemented using <code>cobra</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformlayer-controller","title":"The TerraformLayer Controller","text":"<p>The status of a <code>TerraformLayer</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions are defined for a layer:</p> <ul> <li><code>IsPlanArtifactUpToDate</code>. This condition is used for drift detection. The evaluation is made by compraing the timestamp of the last <code>terraform plan</code> which ran and the current date. The timestamp of the last plan is \"stored\" using an annotation.</li> <li><code>IsApplyUpToDate</code>. This condition is used to check if an <code>apply</code> needs to run after the last <code>plan</code>. Comparison is made by comparing a checksum of the last planned binary and a checksum last applied binary stored in the annotations.</li> <li><code>IsLastRelevantCommitPlanned</code>. This condition is used to check if a new commit has been made to the layer and need to be applied. It is evaluated by comparing the commit used for the last <code>plan</code>, the last commit which intoduced changes to the layer and the last commit made to the same branch of the repository. Those commits are \"stored\" as annotations.</li> </ul> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a layer if no runner needs be started</li> <li><code>PlanNeeded</code>. This is the state of a layer if burrito needs to start a <code>plan</code> runner</li> <li><code>ApplyNeeded</code>. This is the state of a layer if burrito needs to start an <code>apply</code> runner</li> </ul> <p>Info</p> <p>If you use <code>dry</code> remediation strategy and an apply is needed, the layer will stay in the <code>ApplyNeeded</code> as long as it does not need to enter the <code>PlanNeeded</code>.</p>"},{"location":"operator-manual/architecture/#the-terraformrun-controller","title":"The TerraformRun Controller","text":"<p>The status of a <code>TerraformRun</code> is also defined using the same conditions standards defined by the community.</p> <p>5 conditions are defined for a run:</p> <ul> <li><code>HasStatus</code>. This condition is used to check if a <code>TerraformRun</code> has already been reconciled by the controller.</li> <li><code>HasReachedRetryLimit</code>. Used to check if a <code>TerraformRun</code> has reached the maximum number of retries.</li> <li><code>HasSucceeded</code>. Used to check if a <code>TerraformRun</code> has already succeeded (runner pod exited successfully).</li> <li><code>IsRunning</code>. Used to check if a <code>TerraformRun</code> is currently running by checking the current phase of its associated pod.</li> <li><code>IsInfailureGracePeriod</code>. This condition is used to check if a Terraform workflow has already failed. If so, we use an exponential backoff strategy before restarting a runner on the given layer.</li> </ul> <p>With those 5 conditions, we defined 6 states:</p> <ul> <li><code>Initial</code>. This is the state of a run when it has just been created and has launched its first runner pod.</li> <li><code>Running</code>. This is the state of a run if a runner pod is currently running.</li> <li><code>FailureGracePeriod</code>. This is the state of a layer if a <code>plan</code> or <code>apply</code> runner has failed</li> <li><code>Retrying</code>. This is an intermediate state of a run if a runner pod has failed and is being restarted (not in failure grace period anymore).</li> <li><code>Succeeded</code>. This is one of the two final states a run can have. It means that the runner pod has exited successfully.</li> <li><code>Failed</code>. This is the other final state a run can have. It means that the run has failed multiple times and has reached the maximum number of retries.</li> </ul> <p>The <code>TerraformRun</code> controller also creates and deletes the Kubernetes leases to avoid concurrent use of Terraform on the same layer.</p>"},{"location":"operator-manual/architecture/#the-runners","title":"The runners","text":"<p>The runner implementation relies on <code>tenv</code>, a tool from the community which allows us to dynamically download and use any version of Terraform, Terragrunt or OpenTofu (coming soon). Thus, we support any existing version of Terraform.</p> <p>If no version constraint is set in the TerraformLayer resource or in the TerraformRepository resource, <code>tenv</code> will detect which version of Terraform/Terragrunt/OpenTofu to use by looking at the version constraints in your code.</p> <p>The runner is responsible to update the annotations of the layer it is associated to to store information about what commit was planned/applied and when.</p>"},{"location":"operator-manual/datastore/","title":"Datastore","text":""},{"location":"operator-manual/datastore/#configuration","title":"Configuration","text":"<p>The Datastore storage backend can be configured using the following yaml configuration :</p> <pre><code>config:\n  burrito:\n    datastore:\n      storage:\n        encryption:\n          enabled: &lt;false|true&gt; # default: false\n        mock: &lt;false|true&gt; # default: false\n        s3:\n          bucket: &lt;bucket-name&gt;\n          usePathStyle: &lt;false|true&gt; # default: false\n        gcs:\n          bucket: &lt;bucket-name&gt;\n        azure:\n          storageAccount: &lt;storage-account&gt;\n          container: &lt;container-name&gt;\n</code></pre> <p>Info</p> <p>Only one storage backend can be configured at a time.</p> <p>Warning</p> <p>The <code>mock</code> storage backend is only for testing purposes and should not be used in production. If enabled, Burrito will store the data in memory and will lose it when the pod is restarted. It also might fill up the memory of the pod if too much data is stored.</p>"},{"location":"operator-manual/datastore/#encryption","title":"Encryption","text":""},{"location":"operator-manual/datastore/#configuration_1","title":"Configuration","text":"<p>Burrito supports encryption of data at rest in the datastore. When encryption is enabled, all data stored in the backend storage will be encrypted using AES-256-CBC. This allows you to decrypt with external tools such as <code>openssl</code></p> <p>To enable encryption, you need to:</p> <ol> <li>Set <code>encryption.enabled: true</code> in the configuration</li> <li>Provide an encryption key via the <code>BURRITO_DATASTORE_STORAGE_ENCRYPTION_KEY</code> environment variable, through a Kubernetes secret like below</li> </ol> <pre><code>config:\n  burrito:\n    datastore:\n      storage:\n        encryption:\n          enabled: true\n\ndatastore:\n  deployment:\n    envFrom:\n      - secretRef:\n          name: burrito-datastore-encryption-key\n</code></pre> <p>You'll need to create a secret containing the encryption key:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-datastore-encryption-key\n  namespace: &lt;datastoreNamespace&gt;\ntype: Opaque\nstringData:\n  BURRITO_DATASTORE_STORAGE_ENCRYPTION_KEY: &lt;your-encryption-key&gt;\n</code></pre> <p>Warning</p> <p>Losing the encryption key will make all encrypted data unrecoverable. Make sure to back up your encryption key securely.</p> <p>You can generate a key with:</p> <pre><code>openssl rand -hex 32\n</code></pre>"},{"location":"operator-manual/datastore/#security-notes","title":"Security Notes","text":"<ul> <li>Always keep your encryption keys secure</li> <li>The IV is stored in plaintext at the beginning of each encrypted file (this is standard practice)</li> <li>Each encryption operation uses a random IV, ensuring the same plaintext produces different ciphertext</li> </ul>"},{"location":"operator-manual/datastore/#files-format","title":"Files format","text":"<p>The encrypted files use the following format:</p> <ul> <li>First 16 bytes: Initialization Vector (IV)</li> <li>Remaining bytes: AES-256-CBC encrypted data with PKCS#7 padding</li> </ul> <p>The encryption key is derived by taking the SHA-256 hash of the provided key string.</p>"},{"location":"operator-manual/datastore/#decrypting-with-openssl","title":"Decrypting with OpenSSL","text":"<p>You have downloaded the encrypted file, you can now start to decrypt it:</p> <pre><code># Extract the first 16 bytes (IV) as hex\nIV_HEX=$(xxd -l 16 -p plan.json)\n\n# derivate your key with sha256\nKEY_HASH=$(echo -n \"your-encryption-key\" | sha256sum | cut -d' ' -f1)\n\n# decrypt the file\nopenssl enc -aes-256-cbc -d -in plan.json -K \"${KEY_HASH}\" -iv \"${IV_HEX}\"\n</code></pre>"},{"location":"operator-manual/datastore/#encrypting-existing-files","title":"Encrypting existing files","text":"<p>If you enable encryption on an existing datastore with unencrypted files, you can use the <code>/encrypt</code> endpoint to encrypt all existing files. See the Encrypt Endpoint documentation for detailed usage instructions.</p>"},{"location":"operator-manual/datastore/#authentication","title":"Authentication","text":"<p>The different cloud provider implementations rely on the default credentials chain of the cloud provider SDKs. Use annotations and labels on the service account associated to the datastore by updating the <code>datastore.serviceAccount.metadata</code> field to specify the credentials to use. (e.g. <code>iam.amazonaws.com/role</code> for AWS)</p>"},{"location":"operator-manual/datastore/#authorization","title":"Authorization","text":"<p>The Datastore relies on TokenReview and mounted volumes for authorization. We rely on a custom audience for the TokenReview to ensure that the token can only be used for the Datastore.</p>"},{"location":"operator-manual/datastore/#object-expiration","title":"Object expiration","text":"<p>For now the datastore doesn't delete any object it puts into the storage backend. This is a feature that will be implemented in the future.</p>"},{"location":"operator-manual/datastore/#private-s3-endpoint","title":"Private S3 endpoint","text":"<p>You can use a private endpoint for S3, like Ceph or Minio. To do so, you'll need to create a secret:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: s3-secrets\n  namespace: &lt;datastoreNamespace&gt;\ntype: Opaque\nstringData:\n  AWS_ACCESS_KEY_ID: xxx\n  AWS_SECRET_ACCESS_KEY: xxx\n  AWS_ENDPOINT_URL_S3: https://s3.domain.com\n  AWS_REGION: yourRegion\n</code></pre> <p>where <code>&lt;datastoreNamespace&gt;</code> is the namespace on which datastore is installed (<code>burrito-system</code> by default)</p> <p>In your Helm chart values, you'll also need to tell datastore to use this secret as environment variables:</p> <pre><code>config:\n  burrito:\n    datastore:\n      storage:\n        mock: false\n        s3:\n          bucket: &lt;bucketName&gt;\n          usePathStyle: true\n\ndatastore:\n  deployment:\n    envFrom:\n      - secretRef:\n          name: s3-secrets\n</code></pre>"},{"location":"operator-manual/encrypt-endpoint/","title":"Encrypt Endpoint","text":"<p>The <code>/encrypt</code> endpoint allows you to encrypt all files in the datastore. This is useful when you need to migrate from unencrypted to encrypted storage.</p>"},{"location":"operator-manual/encrypt-endpoint/#endpoint","title":"Endpoint","text":"<p><code>POST /api/encrypt</code></p>"},{"location":"operator-manual/encrypt-endpoint/#request-body","title":"Request Body","text":"<pre><code>{\n  \"encryptionKey\": \"your-encryption-key\"\n}\n</code></pre>"},{"location":"operator-manual/encrypt-endpoint/#parameters","title":"Parameters","text":"<ul> <li><code>encryptionKey</code> (required): The encryption key that must match the server's configured encryption key</li> </ul>"},{"location":"operator-manual/encrypt-endpoint/#authentication","title":"Authentication","text":"<p>The endpoint requires the same authentication as other datastore endpoints (service account token).</p>"},{"location":"operator-manual/encrypt-endpoint/#response","title":"Response","text":""},{"location":"operator-manual/encrypt-endpoint/#success-response-200-ok","title":"Success Response (200 OK)","text":"<pre><code>{\n  \"message\": \"Encryption process completed. X files encrypted.\",\n  \"filesEncrypted\": 42,\n  \"errors\": []\n}\n</code></pre>"},{"location":"operator-manual/encrypt-endpoint/#partial-success-response-206-partial-content","title":"Partial Success Response (206 Partial Content)","text":"<pre><code>{\n  \"message\": \"Encryption process completed. X files encrypted.\",\n  \"filesEncrypted\": 38,\n  \"errors\": [\n    \"Failed to encrypt layers/namespace/layer/run/attempt/file.json: error details\",\n    \"Failed to encrypt repositories/namespace/repo/branch/commit.gitbundle: error details\"\n  ]\n}\n</code></pre>"},{"location":"operator-manual/encrypt-endpoint/#error-responses","title":"Error Responses","text":""},{"location":"operator-manual/encrypt-endpoint/#400-bad-request","title":"400 Bad Request","text":"<ul> <li>Missing encryption key in request body</li> <li>Encryption is not enabled in configuration</li> </ul>"},{"location":"operator-manual/encrypt-endpoint/#401-unauthorized","title":"401 Unauthorized","text":"<ul> <li>Invalid encryption key (doesn't match server configuration)</li> </ul>"},{"location":"operator-manual/encrypt-endpoint/#500-internal-server-error","title":"500 Internal Server Error","text":"<ul> <li>No encryption key configured on server</li> </ul>"},{"location":"operator-manual/encrypt-endpoint/#usage-example","title":"Usage Example","text":""},{"location":"operator-manual/encrypt-endpoint/#authorization-configuration","title":"Authorization Configuration","text":"<p>By default, burrito comes with these authorized service accounts:</p> <ul> <li><code>burrito-project/burrito-runner</code></li> <li><code>burrito-system/burrito-controllers</code> </li> <li><code>burrito-system/burrito-server</code></li> </ul> <p>To add additional service accounts, update your Helm values:</p> <pre><code>config:\n  burrito:\n    datastore:\n      serviceAccounts:\n        - burrito-project/burrito-runner\n        - burrito-system/burrito-controllers\n        - burrito-system/burrito-server\n        - burrito-system/your-custom-service-account # Add custom accounts here\n</code></pre>"},{"location":"operator-manual/encrypt-endpoint/#usage-examples","title":"Usage Examples","text":"<p>Once you have the token, use it in your API calls:</p> <pre><code># enable port-forward to your datastore\nkubectl port-forward $(kubectl get pods -n burrito-system | awk '/burrito-datastore/{print $1}') -n burrito-system 8080:8080\n\n# Get a token using the burrito-server service account (recommended)\nTOKEN=$(kubectl create token burrito-server -n burrito-system --audience=burrito)\n\n# Use it with curl\ncurl -X POST http://localhost:8080/api/encrypt \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: $TOKEN\" \\\n  -d '{\"encryptionKey\": \"your-encryption-key\"}'\n</code></pre>"},{"location":"operator-manual/encrypt-endpoint/#prerequisites","title":"Prerequisites","text":"<ol> <li>Encryption must be enabled in the datastore configuration</li> <li>The <code>BURRITO_DATASTORE_STORAGE_ENCRYPTION_KEY</code> environment variable must be set</li> <li>The provided encryption key must match the configured server key</li> <li>A service account with proper authorization must be configured (see \"Getting the Authorization Bearer Token\" section)</li> <li>The service account must be listed in the datastore's <code>serviceAccounts</code> configuration</li> </ol>"},{"location":"operator-manual/encrypt-endpoint/#behavior","title":"Behavior","text":"<ul> <li>The endpoint will list all files in <code>layers/</code> prefix</li> <li>For each file, it tests if the file is already encrypted by attempting to decrypt it</li> <li>Files that are already encrypted will be skipped - no double encryption occurs</li> <li>Only unencrypted files will be encrypted and stored back</li> <li>The process continues even if some files fail to encrypt</li> <li>Progress is logged every 100 files processed</li> <li>The response includes the count of files that were actually encrypted (skipped files are not counted)</li> </ul>"},{"location":"operator-manual/git-authentication/","title":"Git Authentication","text":""},{"location":"operator-manual/git-authentication/#overview","title":"Overview","text":"<p>This section will guide you through the different ways to authenticate to a git repository. Authentication is required for:</p> <ul> <li>Cloning a private repository</li> <li>Implementing the PR/MR workflow</li> <li>Setting up the webhook for listening to push / pull requests events</li> </ul> <p>Available authentication methods:</p> <ul> <li>Username and password (only supports cloning)</li> <li>SSH private key (only supports cloning)</li> <li>GitHub App</li> <li>GitHub API token</li> <li>GitLab API token</li> </ul>"},{"location":"operator-manual/git-authentication/#repository-secret","title":"Repository Secret","text":"<p>The <code>TerraformRepository</code> spec allows you to specify a secret that contains the credentials to authenticate to a git repository. The secret must be created in the same namespace as the <code>TerraformRepository</code> and be referenced in <code>spec.repository.secretName</code>.</p>"},{"location":"operator-manual/git-authentication/#expected-keys","title":"Expected keys","text":"<p>To add an authentication method for a repository, the secret must contain the following keys:</p> <p>Username and password (Git's HTTPS authentication):</p> <ul> <li><code>username</code></li> <li><code>password</code></li> </ul> <p>SSH private key (Git's SSH authentication):</p> <ul> <li><code>sshPrivateKey</code></li> </ul> <p>GitHub App:</p> <ul> <li><code>githubAppId</code></li> <li><code>githubAppInstallationId</code></li> <li><code>githubAppPrivateKey</code></li> </ul> <p>GitHub API token:</p> <ul> <li><code>githubToken</code></li> </ul> <p>GitLab API token:</p> <ul> <li><code>gitlabToken</code></li> </ul> <p>For the PR/MR workflow, the Kubernetes secret must also contain the webhook secret:</p> <ul> <li><code>webhookSecret</code></li> </ul> <p>Example of a Kubernetes secret for a GitHub repository, using authentication with a GitHub App and implementing the PR workflow:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: burrito-project\ntype: Opaque\nstringData:\n  githubAppId: \"123456\"\n  githubAppInstallationId: \"12345678\"\n  githubAppPrivateKey: |\n    -----BEGIN RSA PRIVATE KEY-----\n    my-private-key\n    -----END RSA PRIVATE KEY-----\n  webhookSecret: \"my-webhook-secret\"\n</code></pre>"},{"location":"operator-manual/git-authentication/#behavior","title":"Behavior","text":"<p>If multiple authentication methods are provided, the runner will try them all until one succeeds to clone the repository.</p>"},{"location":"operator-manual/git-webhook/","title":"Setup a Git Webhook","text":""},{"location":"operator-manual/git-webhook/#expose-burrito-server-to-the-internet","title":"Expose Burrito server to the internet","text":"<p>Expose the <code>burrito-server</code> service to the internet using the method of your choice. (e.g. ingress, port-forward &amp; ngrok for local testing...). Accessing the URL on the browser should display the Burrito UI.</p>"},{"location":"operator-manual/git-webhook/#configure-a-webhook-on-github-or-gitlab","title":"Configure a webhook on GitHub or GitLab","text":"<p>Create a webhook (with a secret!) in the repository you want to receive events from. The target URL must point to the exposed <code>burrito-server</code> on the <code>/api/webhook</code> path.</p> <p>GitHub triggers: The webhook should be triggered on <code>push</code> and <code>pull_request</code> events.</p> <p>GitLab triggers: The webhook should be triggered on <code>Push events</code> from all branches and <code>Merge request events</code>.</p>"},{"location":"operator-manual/git-webhook/#reference-the-webhook-secret-in-the-repository-secret","title":"Reference the webhook secret in the repository secret","text":"<p>Add the webhook secret to the secret used to authenticate to the repository. If the repository is public, create a secret in the same namespace as the <code>TerraformRepository</code> and reference it in the <code>spec.repository.secretName</code>. Reference the webhook secret in the webhookSecret key of the Kubernetes secret.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/owner/repo\n    secretName: burrito-repo\n  terraform:\n    enabled: true\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: burrito-project\ntype: Opaque\nstringData:\n  githubAppId: \"123456\"\n  githubAppInstallationId: \"12345678\"\n  githubAppPrivateKey: |\n    -----BEGIN RSA PRIVATE KEY-----\n    my-private-key\n    -----END RSA PRIVATE KEY-----\n  webhookSecret: \"my-webhook-secret\" \n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/","title":"Multi-tenant architecture","text":"<p>With our Helm chart we provide a way to setup multi-tenancy with burrito. This is useful when working at scale, when you controls multiple Terraform projects with burrito across several teams.</p> <p>The setup is split across multiple Kubernetes namespaces:</p> <ul> <li><code>burrito-system</code> is where burrito's components live and operate (controllers, server, datastore)</li> <li>the other namespaces (<code>tenant-namespace-[1-3]</code> on the schema) where <code>TerraformRepository</code>, <code>TerraformLayer</code>, <code>TerraformRun</code> and <code>TerraformPullRequest</code> resources live and where burrito spawns runner pods for Terraform <code>plan</code> and <code>apply</code> actions.</li> </ul> <p>Thanks to Kubernetes native RBAC system you can restrict access for your users only to the namespaces their burrito resources live.</p>"},{"location":"operator-manual/multi-tenant-architecture/#configuring-multi-tenancy-with-the-helm-chart","title":"Configuring multi-tenancy with the Helm chart","text":""},{"location":"operator-manual/multi-tenant-architecture/#1-configure-basic-tenants","title":"1. Configure basic tenants","text":"<p>In the <code>values.yaml</code> of the Helm chart, add the following:</p> <pre><code>tenants:\n  - namespace:\n      create: true\n      name: tenant-namespace-1\n    serviceAccounts:\n      - name: runner-project\n  - namespace:\n      create: true\n      name: tenant-namespace-2\n    serviceAccounts:\n      - name: runner-project\n  - namespace:\n      create: true\n      name: tenant-namespace-3\n    serviceAccounts:\n      - name: runner-project\n</code></pre> <p>This setup creates 3 tenants with 3 namespaces with one service account in each namespace.</p> <p>The chart adds every tenant referenced in its values in the namespaces that the burrito controllers must watch.</p> <p>You can also customize namespaces' labels and annotations:</p> <pre><code>tenants:\n  - namespace:\n      create: true\n      name: tenant-namespace-1\n      labels:\n        app.kubernetes.io/part-of: project-1\n      annotations:\n        helm.sh/resource-policy: keep\n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/#2-configure-service-accounts","title":"2. Configure service accounts","text":"<p>Each service account created in a tenant is bound to the <code>burrito-runner</code> ClusterRole, it is a basic role with the required permissions for a burrito runner pod to work properly.</p> <p>You can add additional role bindings to the service accounts if you need special permissions in the cluster (e.g. a Terraform layer deploying to Kubernetes) as well as annotations and labels (e.g. assume a role on a cloud provider).</p> <pre><code>  - namespace:\n      create: true\n      name: tenant-namespace-1\n    serviceAccounts:\n      - name: runner-kubernetes\n        additionalRoleBindings:\n          - name: custom\n            role:\n              kind: ClusterRole\n              name: custom-role\n      - name: runner-google\n        labels:\n          app.kubernetes.io/part-of: project-1\n        annotations:\n          iam.gke.io/gcp-service-account: burrito-project-1@company-project.iam.gserviceaccount.com\n      - name: runner-aws\n        annotations:\n          eks.amazonaws.com/role-arn: arn:aws:iam::111122223333:role/my-role\n</code></pre>"},{"location":"operator-manual/multi-tenant-architecture/#3-use-service-accounts-in-the-tenant","title":"3. Use service accounts in the tenant","text":"<p>For the <code>TerraformRepository</code> or <code>TerraformLayer</code> you deploy in a tenant, you can use the <code>overrideRunnerSpec</code> parameter to select which service account to use for runners affected to a layer/repository.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: infra-aws\n  namespace: tenant-namespace-1\nspec:\n  terraform:\n    version: \"1.5.3\"\n  path: \"infra/layers/aws/production\"\n  branch: \"main\"\n  repository:\n    name: project-1\n    namespace: tenant-namespace-1\n  overrideRunnerSpec:\n    serviceAccountName: runner-aws # &lt;-- Specify service account here\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/","title":"PR/MR Workflow","text":"<p>Info</p> <p>In this documentation all references to pull requests can be change to merge requests for GitLab. However, the resulting Kubernetes object will still be named <code>TerraformPullRequest</code>.</p>"},{"location":"operator-manual/pr-mr-workflow/#components","title":"Components","text":""},{"location":"operator-manual/pr-mr-workflow/#the-server","title":"The server","text":"<p>Info</p> <p>For more information about the server, see the architectural overview documentation.</p> <p>Upon receiving a Pull Request creation event, the server creates a <code>TerraformPullRequest</code> resource.</p> <p>Upon receiving a Pull Request deletion event, the server deletes the related <code>TerraformPullRequest</code> resource.</p>"},{"location":"operator-manual/pr-mr-workflow/#the-pull-request-controller","title":"The pull request controller","text":"<p>The pull request controller is a Kubernetes controller which continuously monitors declared <code>TerraformPullRequest</code> resources.</p> <p>It is responsible for creating temporary <code>TerraformLayer</code> resources linked to the Pull Request it was generated from. Once all the <code>TerraformLayer</code> have planned, it will send a comment containing the plan results to the pull request.</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#implementation","title":"Implementation","text":"<p>The status of a <code>TerraformPulLRequest</code> is defined using the conditions standards defined by the community.</p> <p>3 conditions ared defined for a pull request:</p> <ul> <li><code>IsLastCommitDiscovered</code>. This condition is used to check if we received a new commit on the pull request by comparing the latest commit on the branch and the last discovered commit.</li> <li><code>AreLayersStillPlanning</code>. This condition is used to check if all the temporary layers have finished planning. This is done by checking all the resulting <code>TerraformLayer</code> statuses.</li> <li><code>IsCommentUpToDate</code>. This condition is used to check if the controller needs to send a comment to a pull request. This is checked by comparing the last discovered commit and the last commit for which a comment was already sent.</li> </ul> <p>Info</p> <p>We use annotations to store information.</p> <p>With those 3 conditions, we defined 3 states:</p> <ul> <li><code>Idle</code>. This is the state of a pull request if nothing needs to be done.</li> <li><code>DiscoveryNeeded</code>. This is the state of a pull request if the controller needs to check which layers are affected on the given pull request.</li> <li><code>CommentNeeded</code>. This is the state of a pull request if the controller needs to send a comment to the git provider's API.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configuration","title":"Configuration","text":""},{"location":"operator-manual/pr-mr-workflow/#webhook","title":"Webhook","text":"<p>Follow the instructions in Setting up a Git Webhook to configure a webhook in your repository. The webhook will be used to trigger:</p> <ul> <li>Drift detection when a push event is received.</li> <li>The PR/MR workflow when a pull request event is received.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#github-with-a-dedicated-github-app","title":"GitHub with a dedicated GitHub App","text":""},{"location":"operator-manual/pr-mr-workflow/#create-the-github-app","title":"Create the GitHub App","text":"<p>You can create and register GitHub Apps in your personal GitHub account or in any GitHub organization where you have administrative access.</p> <p>Follow the instructions in the GitHub documentation on Creating a GitHub App. Populate the settings as follows:</p> <ul> <li>GitHub App Name: Choose a name for your GitHub App. For example, something featuring <code>burrito</code>.</li> <li>Homepage URL: Enter https://docs.burrito.tf.</li> <li>Webhook: Unselect Active. The app doesn't use this webhook events mechanism at the moment.</li> <li>Permissions: Configure the following Repository Permissions:<ul> <li>Metadata: Select Read-only.</li> <li>Pull requests: Select Read &amp; write. This is required to issue comments on pull requests.</li> </ul> </li> <li>Where can this GitHub App be installed: Select Any account.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#creating-a-custom-badge-for-your-github-app","title":"Creating a custom badge for your GitHub App","text":"<p>You can create a custom badge for your GitHub App to display on your GitHub repository. Follow the instructions in the GitHub documentation on Creating a custom badge for your GitHub App.</p> <p>We suggest using the following one:</p> <p></p>"},{"location":"operator-manual/pr-mr-workflow/#install-the-github-app","title":"Install the GitHub App","text":"<p>Follow the instructions in the GitHub documentation on Installing your own GitHub App, and note the following:</p> <ul> <li>For Repository access, select Only select repositories, and then select the repos you want to connect with Burrito.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#get-the-installation-id-and-app-id","title":"Get the Installation ID and App ID","text":"<p>You need the Installation ID and App ID to configure Burrito.</p> <ol> <li> <p>Get the Installation ID from the URL of the installed app, such as:  <p></p></p> </li> <li> <p>Get the App ID from the app's General tab.  <p></p></p> </li> </ol>"},{"location":"operator-manual/pr-mr-workflow/#generate-a-private-key","title":"Generate a private key","text":"<p>You need a private key for your GitHub app to configure Burrito.</p> <ul> <li> <p>Follow the instructions in the GitHub documentation for generating private keys for GitHub Apps</p> </li> <li> <p>Save the private key file to your local machine. GitHub only stores the public portion of the key.</p> </li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configure-a-repository-secret-with-the-github-app-credentials","title":"Configure a repository secret with the GitHub App credentials","text":"<p>Add the credentials of your newly created app to the secret associated to your <code>TerraformRepository</code> resource. If the repository is public, create a secret in the same namespace as the <code>TerraformRepository</code> and reference it in the <code>spec.repository.secretName</code>.</p> <p>For example:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/owner/repo\n    secretName: burrito-repo\n  terraform:\n    enabled: true\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: burrito-project\ntype: Opaque\nstringData:\n  webhookSecret: \"my-webhook-secret\"\n  githubAppId: \"123456\"\n  githubAppInstallationId: \"12345678\"\n  githubAppPrivateKey: |\n    -----BEGIN RSA PRIVATE KEY-----\n    my-private-key\n    -----END RSA PRIVATE KEY-----\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/#github-with-a-personal-access-token","title":"GitHub with a personal access token","text":""},{"location":"operator-manual/pr-mr-workflow/#generate-a-personal-access-token","title":"Generate a personal access token","text":"<p>You need a personal access token to configure Burrito. You can generate a personal access token in your GitHub account.</p> <p>Follow the instructions in the GitHub documentation for creating a personal access token:</p> <ul> <li>It should be a fine-grained token.</li> <li>Permissions: Configure the following Repository Permissions:<ul> <li>Metadata: Select Read-only.</li> <li>Pull requests: Select Read &amp; write. This is required to issue comments on pull requests.</li> </ul> </li> <li>Under Repository access, select which repositories you want the token to access.</li> </ul>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito","title":"Configure Burrito","text":"<p>Set the <code>githubToken</code> key in the secret associated to your <code>TerraformRepository</code> resource.</p> <p>For example:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/owner/repo\n    secretName: burrito-repo\n  terraform:\n    enabled: true\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: burrito-project\ntype: Opaque\nstringData:\n  githubToken: \"123456\"\n</code></pre>"},{"location":"operator-manual/pr-mr-workflow/#gitlab","title":"GitLab","text":""},{"location":"operator-manual/pr-mr-workflow/#generate-a-private-token","title":"Generate a private token","text":"<p>You need a private token for your GitLab app to configure Burrito. You can generate a private token in your GitLab account. Follow the instructions in the GitLab documentation for generating a private token.</p>"},{"location":"operator-manual/pr-mr-workflow/#configure-burrito_1","title":"Configure Burrito","text":"<p>Set the <code>gitlabToken</code> key in the secret associated to your <code>TerraformRepository</code> resource.</p> <p>For example:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://gitlab.com/owner/repo\n    secretName: burrito-repo\n  terraform:\n    enabled: true\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: burrito-repo\n  namespace: burrito-project\ntype: Opaque\nstringData:\n  gitlabToken: \"123456\"\n</code></pre>"},{"location":"operator-manual/provider-caching/","title":"Caching Terraform Providers","text":"<p>By caching Terraform providers, Burrito can avoid downloading them from outside the cluster every time a runner initializes a Terraform layer. This can significantly reduce the ingress traffic to the infrastructure running Burrito.</p> <p>The Burrito Helm chart is packaged with Hermitcrab, which leverages the Provider Network Mirror Protocol from Terraform to cache providers.</p>"},{"location":"operator-manual/provider-caching/#1-activate-hermitcrab-on-burrito","title":"1. Activate Hermitcrab on Burrito","text":"<p>Hermitcrab is available to use with Burrito when using the Helm chart. Set the <code>config.burrito.hermitcrab</code> parameter to true in your values file to activate Hermitcrab.</p> <p>As the Provider Network Mirror Protocol only supports HTTPS traffic, it is required to provide Burrito runners &amp; the Hermitcrab server with some TLS configuration. By default, the Helm chart expects a secret named <code>burrito-hermitcrab-tls</code> to contain TLS configuration: <code>ca.crt</code>, <code>tls.crt</code>, and <code>tls.key</code>.</p>"},{"location":"operator-manual/provider-caching/#option-1-use-cert-manager","title":"Option 1: Use Cert-Manager","text":"<p>The Helm chart is packaged with Cert-Manager configuration to use for Burrito/Hermitcrab TLS encryption. Assuming that Cert-Manager is installed on your cluster, set the <code>hermitcrab.tls.certmanager.use</code> parameter to <code>true</code>. This setting adds a Cert-Manager Certificate resource to be used with Burrito. Provide Certificate spec with the <code>hermitcrab.tls.certmanager.spec</code> value. You must set the <code>secretName</code> value to the same value specified in <code>config.burrito.hermitcrab.certificateSecretName</code> (default <code>burrito-hermitcrab-tls</code>)</p>"},{"location":"operator-manual/provider-caching/#example-configuration-with-a-self-signed-issuer","title":"Example configuration with a self-signed issuer","text":"<p>Deploy Cert-Manager resources to generate self-signed certificates:</p> <pre><code>apiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: selfsigned-issuer\nspec:\n  selfSigned: {}\n---\napiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: my-selfsigned-ca\n  namespace: cert-manager\nspec:\n  isCA: true\n  commonName: my-selfsigned-ca\n  secretName: root-secret\n  privateKey:\n    algorithm: ECDSA\n    size: 256\n  issuerRef:\n    name: selfsigned-issuer\n    kind: ClusterIssuer\n    group: cert-manager.io\n---\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: my-ca-issuer\nspec:\n  ca:\n    secretName: root-secret\n</code></pre> <p>Update the Helm chart values to create a self-signed certificate:</p> <pre><code>config:\n  burrito:\n    hermitcrab:\n      enabled: true\n...\nhermitcrab:\n  tls:\n    certManager:\n      use: true\n      certificate:\n        spec:\n          secretName: burrito-hermitcrab-tls\n          commonName: burrito-hermitcrab.burrito.svc.cluster.local\n          dnsNames:\n            - burrito-hermitcrab.burrito.svc.cluster.local\n          issuerRef:\n            name: my-ca-issuer\n            kind: ClusterIssuer\n</code></pre> <p>Burrito runners should now use Hermitcrab as a network mirror for caching providers.</p>"},{"location":"operator-manual/provider-caching/#option-2-mount-a-custom-certificate","title":"Option 2: Mount a custom certificate","text":"<p>If Hermitcrab is activated using the Helm chart, Burrito expects a secret named <code>burrito-hermitcrab-tls</code> to contain TLS configuration: <code>ca.crt</code>, <code>tls.crt</code>, and <code>tls.key</code>. Assuming that Cert-Manager is installed on your cluster, set the <code>tls.certManager.use</code> value to true and specify an Issuer or ClusterIssuer with <code>tls.certManager.certificate.issuer.kind</code> and <code>tls.certManager.certificate.issuer.name</code> values. This will create a Certificate custom resource that will be used to ensure TLS between runners and Hermitcrab.</p>"},{"location":"operator-manual/provider-caching/#server-side","title":"Server side","text":"<p>Mount your custom certificate to <code>/etc/hermitcrab/tls/tls.crt</code> and the private key to <code>/etc/hermitcrab/tls/tls.key</code> by using the <code>hermitcrab.deployment.extraVolumeMounts</code> and <code>hermitcrab.deployment.extraVolumeMounts</code> values. Check out the Hermitcrab documentation for more information about injecting TLS Configuration.</p>"},{"location":"operator-manual/provider-caching/#runner-side","title":"Runner side","text":"<p>If Hermitcrab is activated using the Helm chart, the Burrito controller expects a secret named <code>burrito-hermitcrab-tls</code> to contain client TLS configuration in the <code>ca.crt</code> key. This private certificate will be trusted by Burrito runners.</p>"},{"location":"operator-manual/runner-scheduling/","title":"Fine-tuning the scheduling of runner pods","text":"<p>Burrito creates runner pods to execute plans and apply changes on your infrastructure. The scheduling of these pods can be fine-tuned to better fit your needs. (e.g. to avoid running too many pods at the same time, or to reduce the cost of your underlying infrastructure).</p>"},{"location":"operator-manual/runner-scheduling/#limit-the-number-of-runner-pods-in-parallel","title":"Limit the number of runner pods in parallel","text":"<p>By default, Burrito does not limit the number of runner pods that can run in parallel. This can lead to a high number of pods running at the same time, which can be costly or can overload your infrastructure.</p> <p>It is possible to limit the number of runner pods that can run in parallel by setting the <code>BURRITO_CONTROLLER_MAXCONCURRENTRUNNERPODS</code> environment variable in the controller, or by setting the <code>config.burrito.controller.maxConcurrentRunnerPods</code> value in the Helm chart values file.</p> <p>You can also set this value in the TerraformRepository CRD by setting the <code>spec.maxConcurrentRunnerPods</code> field.</p> <p>If the value of this parameter is set to <code>0</code>, there is no limit to the number of runner pods that can run in parallel.</p> <p>When Burrito creates a pod, if the setting is both set in the controller and in the TerraformRepository, the TerraformRepository value will take precedence.</p>"},{"location":"reference/","title":"Reference index","text":""},{"location":"user-guide/","title":"Overview","text":"<p>This guide is for developers who have burrito installed for them and are managing layers.</p> <p>Note</p> <p>Please make sure you've completed the getting started guide.</p>"},{"location":"user-guide/additionnal-trigger-path/","title":"Additionnal Trigger Paths","text":"<p>By default, when you are creating a layer, you must specify a repository and a path. This path is used to trigger the layer changes which means that when a change occurs in this path, the layer will be plan / apply accordingly.</p> <p>Sometimes, you need to trigger changes on a layer where the changes are not in the same path (e.g. update made on an internal terraform module hosted on the same repository).</p> <p>That's where the additional trigger paths feature comes!</p> <p>Let's take the following <code>TerraformLayer</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  terraform:\n    enabled: true\n    version: \"1.3.1\"\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets/test\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>The repository's path of my <code>TerraformLayer</code> is set to <code>terragrunt/random-pets/test</code>. But I want to trigger the layer plan / apply when a change occurs on my module which is in the <code>modules/random-pets</code> directory of my repository.</p> <p>To do so, I just have to add the <code>config.terraform.padok.cloud/additionnal-trigger-paths</code> annotation to my <code>TerraformLayer</code> as below. Note you can set several paths separated with a comma.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\n  annotations:\n    config.terraform.padok.cloud/additionnal-trigger-paths: \"modules/random-pets\"\nspec:\n  terraform:\n    enabled: true\n    version: \"1.3.1\"\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets/test\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>Now, when a change occurs in the <code>modules/random-pets</code> directory, the layer will be plan / apply.</p>"},{"location":"user-guide/override-runner/","title":"Override the runner pod spec","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.overrideRunnerSpec</code> map field.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p> <p>Info</p> <ul> <li>Maps (dictionaries): A deep merge is performed. Keys in <code>TerraformLayer</code> overwrite those in <code>TerraformRepository</code>, but unmatched keys are preserved.</li> <li>Arrays (lists): Arrays are not merged; they are fully replaced.</li> </ul> <p>Available overrides are:</p> Fields <code>Affinity</code> <code>Args</code> <code>Command</code> <code>ImagePullSecrets</code> <code>Image</code> <code>InitContainers</code> <code>Tolerations</code> <code>NodeSelector</code> <code>ServiceAccountName</code> <code>Resources</code> <code>Env</code> <code>EnvFrom</code> <code>Volumes</code> <code>VolumeMounts</code> <code>Metadata.Annotations</code> <code>Metadata.Labels</code> <code>ExtraInitArgs</code> <code>ExtraPlanArgs</code> <code>ExtraApplyArgs</code> <p>For instance with the following configuration, all the runner pods will have the specifications described inside the <code>TerraformRepository</code>:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito\n  terraform:\n    enabled: true\n  overrideRunnerSpec:\n    imagePullSecrets:\n    - name: ghcr-creds\n    tolerations:\n    - effect: NoSchedule\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector:\n      production: \"true\"\n    serviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>In the following case, <code>nodeSelector</code> will be merged and <code>tolerations</code> will be replaced:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: burrito\n  namespace: burrito\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito\n  terraform:\n    enabled: true\n  overrideRunnerSpec:\n    imagePullSecrets:\n    - name: ghcr-creds\n    tolerations:\n    - effect: NoExecute\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector:\n      production: \"true\"\n    serviceAccountName: \"production\"\n---\napiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets\n  namespace: burrito\nspec:\n  terraform:\n    version: \"1.3.1\"\n  path: \"internal/e2e/testdata/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    tolerations:\n    - effect: NoSchedule\n      key: burrito.io/production\n      operator: Exists\n    nodeSelector: {}\n</code></pre> <p>Resulting in the following <code>podSpec</code>:</p> <pre><code>tolerations:\n- effect: NoSchedule\n  key: burrito.io/production\n  operator: Exists\nnodeSelector:\n  production: \"true\"\n</code></pre>"},{"location":"user-guide/override-runner/#prepare-runner-configuration-with-initcontainers","title":"Prepare runner configuration with <code>initContainers</code>","text":"<p>You may need to get refreshed tokens to access your APIs or prepare some dynamic configuration for Terraform. To do so, you can use <code>initContainers</code>.</p> <p>Note</p> <p>In order to allow access to files generated by your init container from your main container, you'll need to match the uid/gid from the runner image. You can check it here</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: my-layer\nspec:\n  overrideRunnerSpec:\n    volumes:\n      - name: kubeconfig-volume\n        emptyDir: {}\n    volumeMounts:\n      - name: kubeconfig-volume\n        mountPath: /home/burrito/.kube\n        readOnly: true\n    initContainers:\n      - name: init-runner\n        image: registry.domain.com/image:tag\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 65532  # match USER from Dockerfile\n          runAsGroup: 65532 # match USER from Dockerfile\n        command:\n          - 'sh'\n          - '-c'\n          - 'generate-kube-config --output=/.kube/config'\n        envFrom:\n          - secretRef:\n              name: kube-secrets\n        volumeMounts:\n          - mountPath: /.kube\n            name: kubeconfig-volume\n</code></pre>"},{"location":"user-guide/private-modules/","title":"Configure the TerraformLayer to use private modules' repositories","text":"<p>If your stack use Terraform modules that are hosted on private repositories, you can configure the <code>TerraformLayer</code> to be able to use those private modules by configuring the <code>overrideRunnerSpec</code> in your resource definition.</p>"},{"location":"user-guide/private-modules/#the-layer-uses-a-private-module-with-https","title":"The layer uses a private module with HTTPS","text":""},{"location":"user-guide/private-modules/#1-create-a-secret-containing-a-git-credentilas-file","title":"1. Create a secret containing a .git-credentilas file","text":"<p>Create a Kubernetes Secret which looks like the following:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: git-credentials\nstringData:\n  .git-credentials: |\n    https://&lt;username&gt;:&lt;password | access_token&gt;@github.com\n</code></pre> <p>Info</p> <p>You can replace <code>github.com</code> with <code>gitlab.com</code> or any GitHub or GitLab URL.</p>"},{"location":"user-guide/private-modules/#2-create-a-configmap-for-configuring-the-git-agent","title":"2. Create a ConfigMap for configuring the git agent","text":"<p>Create a Kubernetes ConfigMap which looks like the following:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: gitconfig\ndata:\n  .gitconfig: |\n    [credential]\n        helper = store\n</code></pre>"},{"location":"user-guide/private-modules/#3-mount-those-configurations-files-in-the-runners-configuration","title":"3. Mount those configurations' files in the runners' configuration","text":"<p>You need to mount this Secret and ConfigMap as file with some VolumeMounts:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: terragrunt-private-module\nspec:\n  terraform:\n    enabled: true\n    version: \"1.3.1\"\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets-private-module/test\"\n  branch: main\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    env:\n    volumes:\n    - name: gitconfig\n      configMap:\n        name: gitconfig\n    - name: git-credentials\n      secret:\n        secretName: git-credentials\n    volumeMounts:\n    - name: gitconfig\n      mountPath: /home/burrito/.gitconfig\n      subPath: .gitconfig\n    - name: git-credentials\n      mountPath: /home/burrito/.git-credentials\n      subPath: .git-credentials\n</code></pre>"},{"location":"user-guide/private-modules/#the-layer-uses-a-private-module-with-ssh","title":"The layer uses a private module with SSH","text":""},{"location":"user-guide/private-modules/#1-create-a-secret-with-a-ssh-private-key-which-can-pull-the-modules-repositories","title":"1. Create a Secret with a SSH private key which can pull the modules' repositories","text":"<p>Create a Kubernetes Secret which looks like the following:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: git-private-key\u2013modules\n  namespace: burrito\ntype: Opaque\nstringSata:\n  key: |\n    -----BEGIN OPENSSH PRIVATE KEY-----\n    ...\n    -----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>Info</p> <p>You can update the Kubernetes ConfigmMap <code>burrito-ssh-known-hosts</code> to add others known hosts. See Manage SSH known hosts.</p>"},{"location":"user-guide/private-modules/#2-mount-this-secret-in-your-runner-spec","title":"2. Mount this Secret in your runner spec","text":"<p>You need to mount this Secret as a volume and add a <code>GIT_SSH_COMMAND</code> environements variables:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: terragrunt-private-module-ssh\nspec:\n  terraform:\n    version: \"1.3.1\"\n    enabled: true\n  terragrunt:\n    enabled: true\n    version: \"0.45.4\"\n  remediationStrategy:\n    autoApply: true\n  path: \"terragrunt/random-pets-private-module-ssh/test\"\n  branch: main\n  repository:\n    name: burrito\n    namespace: burrito\n  overrideRunnerSpec:\n    env:\n    - name: GIT_SSH_COMMAND\n      value: ssh -i /home/burrito/.ssh/key\n    volumes:\n    - name: private-key\n      secret:\n        secretName: private-key-ssh-module\n    volumeMounts:\n    - name: private-key\n      mountPath: /home/burrito/.ssh/key\n      subPath: key\n      readOnly: true\n</code></pre> <p>As you can see, we added a new <code>overrideRunnerSpec</code> field to the <code>TerraformLayer</code> spec. This field allows you to override the default runner pod spec. In this case, we added a new volume and a new environment variable to the runner pod spec:</p> <ul> <li>The volume is a secret volume that contains the SSH key we created earlier</li> <li>The environment variable is used to tell git to use the SSH key we added to the runner pod</li> </ul>"},{"location":"user-guide/remediation-strategy/","title":"Choose a remediation strategy","text":"<p>The remediation strategy is the way to tell Burrito how it should handle the remediation of drifts on your Terraform layers.</p> <p>As for the runner spec override, you can specify a <code>spec.remediationStrategy</code> either on the <code>TerraformRepository</code> or the <code>TerraformLayer</code>.</p> <p>The configuration of the <code>TerraformLayer</code> will take precedence.</p>"},{"location":"user-guide/remediation-strategy/#specremediationstrategy-api-reference","title":"<code>spec.remediationStrategy</code> API reference","text":"Field Type Default Effect <code>autoApply</code> Boolean <code>false</code> If <code>true</code> when a <code>plan</code> shows drift, it will run an <code>apply</code>. <code>onError.maxRetries</code> Integer <code>5</code> or value defined in Burrito configuration How many times Burrito should retry a <code>plan</code>/<code>apply</code> when a runner fails. <p>Warning</p> <p>This operator is still experimental. Use <code>spec.remediationStrategy.autoApply: true</code> at your own risk.</p>"},{"location":"user-guide/remediation-strategy/#example","title":"Example","text":"<p>With this example configuration, Burrito will create <code>apply</code> runs for this layer, with a maximum of 3 retries.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  remediationStrategy:\n    autoApply: true\n    onError:\n      maxRetries: 3\n  # ... snipped ...\n</code></pre>"},{"location":"user-guide/ssh-known-hosts/","title":"Manage SSH known hosts","text":""},{"location":"user-guide/ssh-known-hosts/#defaults","title":"Defaults","text":"<p>By default, we provide a list of known hosts with public repositories:</p> <ul> <li>Azure</li> <li>Bitbucket</li> <li>GitHub</li> <li>Gitlab</li> <li>Visual Studio</li> </ul>"},{"location":"user-guide/ssh-known-hosts/#override-known-hosts","title":"Override known hosts","text":"<p>If you need to provide your own keys for other repositories, you can override the default value in the chart with:</p> <pre><code>global:\n  sshKnownHosts: |-\n    git.domain.com ssh-ed25519 AAAAC3Nxxx\n    git.domain.com ssh-rsa AAAAB3Nxxx\n    git.domain.com ecdsa-sha2-nistp256 AAAAE2Vxxx\n</code></pre> <p>To get those keys, you can run: <code>ssh-keyscan git.domain.com 2&gt;&amp;1| grep -vE '^#'</code></p>"},{"location":"user-guide/sync-windows/","title":"Sync Windows","text":"<p>Sync windows are a way to control when Burrito can run <code>apply</code> operations on Terraform layers. This is useful to prevent changes during specific timeframes, like business hours or maintenance windows. A sync window is defined by a kind (<code>allow</code> or <code>deny</code>), a schedule in cron format, a duration and a selector for layers in which wildcard are supported. Sync window can be defined at the repository level or at global level (in the Burrito configuration). The sync window can be applied to <code>plan</code>, <code>apply</code> or both actions.</p>"},{"location":"user-guide/sync-windows/#use-cases","title":"Use Cases","text":"<ul> <li>Blocking all Burrito operations outside of business hours to reduce cloud costs.</li> <li>Preventing Burrito to apply unwanted changes outside of business hours, while keeping drift detection enabled.</li> <li>Allowing only <code>apply</code> operations during specific maintenance windows to ensure that changes are applied at a specific time.</li> </ul>"},{"location":"user-guide/sync-windows/#spec-example","title":"Spec &amp; Example","text":"Field Type Description <code>syncWindows</code> Array The list of sync windows. <code>syncWindows[].kind</code> String The kind of the sync window, either <code>allow</code> or <code>deny</code>. <code>syncWindows[].schedule</code> String The schedule of the sync window in cron format. <code>syncWindows[].duration</code> String The duration of the sync window. <code>syncWindows[].layers</code> Array The list of layers to which the sync window applies (supports wildcards). <code>syncWindows[].actions</code> Array List of actions that are affected by the sync window. <code>[\"plan\"]</code>, <code>[\"apply\"]</code> or <code>[\"plan\",\"apply\"]</code> <p>The following example shows how to define sync windows in a Terraform repository, it is purely to demonstrate the syntax and is not representative of a real-world use case.</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformRepository\nmetadata:\n  name: my-repository\n  namespace: burrito-project\nspec:\n  repository:\n    url: https://github.com/padok-team/burrito-examples.git\n  terraform:\n    enabled: true\n  syncWindows:\n    - kind: allow\n        schedule: \"0 8 * * *\"\n        duration: \"12h\"\n        layers:\n          - \"layer1\"\n          - \"layer2\"\n        actions:\n          - \"plan\"\n          - \"apply\"\n    - kind: deny\n        schedule: \"30 1 * * *\"\n        duration: \"30m\"\n        layers:\n          - \"layer*\"\n        actions:\n          - \"apply\"\n</code></pre>"},{"location":"user-guide/sync-windows/#behavior","title":"Behavior","text":"<p>Sync Windows work as follows:</p> <ul> <li>If no sync window is defined for a layer, the layer is always allowed to be applied.</li> <li>If a deny sync window is defined for a layer, the layer is not allowed to be applied during the sync window.</li> <li>If an allow sync window is defined for a layer, the layer is only allowed to be applied during the sync window.</li> <li>If multiple sync windows are defined for a layer and they overlap, the deny sync window takes precedence over the allow sync window.</li> </ul> <p>The sync window will apply only for the actions defined in the <code>actions</code> field. If the <code>actions</code> field is not defined, the sync window will not apply to any action.</p>"},{"location":"user-guide/sync-windows/#global-sync-windows","title":"Global Sync Windows","text":"<p>Default sync windows are defined in the Burrito configuration and apply to all Burrito reconciliation runs. They are useful to define sync windows that apply to all layers. The default sync windows are defined in the <code>burrito.controller.defaultSyncWindows</code> field of the Burrito configuration. If using helm, you can define the default sync windows in the values file.</p> <pre><code>config:\n  burrito:\n    controller:\n      # -- Default sync windows for layer reconciliation\n      defaultSyncWindows:\n        - kind: allow\n          schedule: \"0 8 * * *\"\n          duration: \"12h\"\n          layers:\n            - \"layer1\"\n            - \"layer2\"\n          actions:\n            - \"plan\"\n            - \"apply\"\n        - kind: deny\n          schedule: \"30 1 * * *\"\n          duration: \"30m\"\n          layers:\n            - \"layer*\"\n          actions:\n            - \"apply\"\n</code></pre>"},{"location":"user-guide/terraform-version/","title":"Configure a Terraform/Terragrunt/OpenTofu version","text":"<p>By leveraging <code>tenv</code>, Burrito auto-detects the Terraform, Terragrunt or OpenTofu version used in your repository, with version constraints set in your code (see <code>tenv</code>'s README).</p> <p>Additionally, you can to specify version constraints in the <code>TerraformRepository</code> or <code>TerraformLayer</code> resource as described below.</p>"},{"location":"user-guide/terraform-version/#choose-terraform-version","title":"Choose Terraform version","text":"<p>Both <code>TerraformRepository</code> and <code>TerraformLayer</code> expose a <code>spec.terraform.version</code> map field that support version constraints as described in the Terraform documentation.</p> <p>If the field is specified for a given <code>TerraformRepository</code> it will be applied by default to all <code>TerraformLayer</code> linked to it.</p> <p>If the field is specified for a given <code>TerraformLayer</code> it will take precedence over the <code>TerraformRepository</code> configuration.</p>"},{"location":"user-guide/terraform-version/#enable-terragrunt","title":"Enable Terragrunt","text":"<p>You can specify usage of Terragrunt with the <code>spec.terraform.terragrunt</code> map as follow:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-terragrunt\nspec:\n  terraform:\n    version: \"~&gt; 1.3.0\"\n    enabled: true\n  terragrunt:\n    enabled: true\n    version: \"0.44.5\"\n  remediationStrategy:\n    autoApply: false\n  path: \"internal/e2e/testdata/terragrunt/random-pets/prod\"\n  branch: \"feat/handle-terragrunt\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre> <p>Info</p> <p>This configuration can be specified at the <code>TerraformRepository</code> level to be enabled by default in each of its layers.</p>"},{"location":"user-guide/terraform-version/#use-opentofu-instead-of-terraform","title":"Use OpenTofu instead of Terraform","text":"<p>To leverage OpenTofu simply use the <code>opentofu</code> block in place of the <code>terraform</code> block described above:</p> <pre><code>apiVersion: config.terraform.padok.cloud/v1alpha1\nkind: TerraformLayer\nmetadata:\n  name: random-pets-opentofu\nspec:\n  opentofu:\n    version: \"~&gt; 1.9.0\"\n    enabled: true\n  path: \"internal/e2e/testdata/terraform/random-pets\"\n  branch: \"main\"\n  repository:\n    name: burrito\n    namespace: burrito\n</code></pre>"}]}